diff --git a/src/main/scala/memory/cache/AXICache.scala b/src/main/scala/memory/cache/AXICache.scala
index 2a3034b2..33a2b50e 100644
--- a/src/main/scala/memory/cache/AXICache.scala
+++ b/src/main/scala/memory/cache/AXICache.scala
@@ -15,31 +15,15 @@ trait HasCacheAccelParams extends HasAccelParams with HasAccelShellParams {
 
   val nWays = accelParams.nways
   val nSets = accelParams.nsets
-  val nStates = accelParams.nstates
-  val addrLen = accelParams.addrlen
-
-  val stateLen = log2Ceil(nStates)
-  val wBytes = xlen / 8
   val bBytes = accelParams.cacheBlockBytes
   val bBits = bBytes << 3
   val blen = log2Ceil(bBytes)
-  val nData = bBits / memParams.dataBits
-  val dataBeats = nData
-  val cNone :: cAlloc :: cDealloc :: cProbe :: cRead :: cWrite::Nil = Enum(accelParams.nCommand + 1)
-
-
-
-  // @//todo to a more generic way
-
   val slen = log2Ceil(nSets)
+  val taglen = xlen - (slen + blen)
   val nWords = bBits / xlen
-
-  //val taglen = xlen - (slen + blen)
-  val taglen = addrLen - (slen + blen + wBytes )
-
+  val wBytes = xlen / 8
   val byteOffsetBits = log2Ceil(wBytes)
-//
-
+  val dataBeats = bBits / memParams.dataBits
 }
 
 
@@ -56,10 +40,6 @@ class MetaData(implicit p: Parameters) extends AXIAccelBundle with HasCacheAccel
   val tag = UInt(taglen.W)
 }
 
-class State(implicit p: Parameters) extends AXIAccelBundle with HasCacheAccelParams {
-  val state = UInt(stateLen.W)
-}
-
 object MetaData {
 
   def apply(tag_len: Int)(implicit p: Parameters): MetaData = {
@@ -81,442 +61,6 @@ object MetaData {
   }
 }
 
-object State {
-
-  def default(implicit p: Parameters): State= {
-    val wire = Wire(new State)
-    wire.state := 0.U
-    wire
-  }
-}
-
-
-class Gem5Cache (val ID:Int = 0, val debug: Boolean = false)(implicit  val p: Parameters) extends Module
-  with HasCacheAccelParams
-  with HasAccelShellParams{
-  val io = IO(new Bundle {
-    val cpu = new CacheCPUIO
-    val mem = new AXIMaster(memParams)
-  })
-
-  val Axi_param = memParams
-  // cache states
-  val (s_IDLE :: s_READ_CACHE :: s_WRITE_CACHE :: s_WRITE_BACK :: s_WRITE_ACK :: s_REFILL_READY :: s_REFILL :: Nil) = Enum(7)
-  val state = RegInit(s_IDLE)
-
-  val s_flush_IDLE :: s_flush_START :: s_flush_ADDR :: s_flush_WRITE :: s_flush_WRITE_BACK :: s_flush_WRITE_ACK :: Nil = Enum(6)
-  val flush_state = RegInit(s_flush_IDLE)
-
-  //Flush Logic
-  //@todo ??
-  val dirty_block = nSets
-
-  // memory
-  val valid    = RegInit(Vec(nSets, 0.U(nWays.W)))
-  val validTag =  RegInit(Vec(nSets, 0.U(nWays.W)))
-  val dirty   = RegInit(Vec(nSets, 0.U(nWays.W)))
-  val stateBit   = RegInit(Vec(nSets, State.default(p)))
-
-  //val metaMem = Vec (nWays, Mem((nSets).toInt, new MetaData))
-  val metaMem = Vec (nWays, Vec((nSets).toInt, new MetaData))
-  val dataMem = Seq.fill(nWords){Mem(nSets * nWays, Vec(wBytes, UInt(8.W)))}
-
-
-
-  def addrToSet( addr:UInt ): UInt={
-    val set = addr(slen + blen + wBytes, blen + wBytes + 1)
-    set.asUInt()
-  }
-  def addrToOffset(addr:UInt): UInt={
-    val offset = addr(blen - 1, byteOffsetBits )
-    offset.asUInt()
-  }
-
-  def addrToTag(addr :UInt): UInt= {
-    val tag = UInt(taglen.W)
-    tag := addr(addrLen - 1, slen + blen + wBytes + 1)
-    tag.asUInt()
-  }
-
-  def addrToLoc ( set:UInt ): (UInt)= {
-    val selFlag = false.B
-    val way = UInt()
-    for (i <- 0 until nWays) {
-      when (validTag(set)(i, i).asUInt() === 0.U && !selFlag){
-        way := i.asUInt()
-        selFlag := true.B
-      }
-    }
-    (way.asUInt())
-  }
-
-  def findInSet (set:UInt , tag: UInt) {
-    val way = nWays.U
-    val MD = new MetaData()
-    MD.tag := tag
-    for (i <- 0 until nWays) yield {
-      when (validTag(set)(i, i).asUInt() === 1.U && metaMem(i)(set).asUInt() === MD.tag){
-        way := i.asUInt()
-      }
-    }
-    way.asUInt()
-
-  }
-
-  def tagValidation(set: UInt, way: UInt){
-    validTag(set).bitSet(way, true.B)
-  }
-
-  def tagInvalidation(set: UInt, way: UInt){
-    validTag(set).bitSet(way, false.B)
-  }
-
-
-
-  val addr_reg    = RegInit(0.U(io.cpu.req.bits.addr.getWidth.W))
-  val cpu_data    = RegInit(0.U(io.cpu.req.bits.data.getWidth.W))
-  val cpu_mask    = RegInit(0.U(io.cpu.req.bits.mask.getWidth.W))
-  val cpu_tag     = RegInit(0.U(io.cpu.req.bits.tag.getWidth.W))
-  val cpu_iswrite = RegInit(0.U(io.cpu.req.bits.iswrite.getWidth.W))
-  val cpu_command = RegInit(0.U(io.cpu.req.bits.command.getWidth.W))
-  val count_set = RegInit(false.B)
-
-  val tag = RegInit(0.U(taglen.W))
-  val set = RegInit(0.U(slen.W))
-  val offset = RegInit(0.U(byteOffsetBits.W))
-
-  when(io.cpu.req.fire()) {
-    addr_reg := io.cpu.req.bits.addr
-    cpu_command := io.cpu.req.bits.command
-    cpu_tag := io.cpu.req.bits.tag
-    cpu_data := io.cpu.req.bits.data
-    cpu_mask := io.cpu.req.bits.mask
-    cpu_iswrite := io.cpu.req.bits.iswrite
-
-    tag := addrToTag(io.cpu.req.bits.addr)
-    set := addrToSet(io.cpu.req.bits.addr)
-    offset := addrToOffset(io.cpu.req.bits.addr)
-  }
-
-
-  // Counters
-  require(nData > 0)
-  val (read_count, read_wrap_out) = Counter(io.mem.r.fire(), nData)
-  val (write_count, write_wrap_out) = Counter(io.mem.w.fire(), nData)
-  //  val (block_count, block_wrap) = Counter(flush_state === s_flush_BLOCK, nWords)
-  val (set_count, set_wrap) = Counter(flush_state === s_flush_START, nSets)
-
-
-  //val block_addr_tag_reg = RegInit(0.U(io.cpu.req.bits.addr.getWidth.W))
-  //@todo get ride of -1
-  val dirty_cache_block = Cat((dataMem map (_.read(set_count - 1.U).asUInt)).reverse)
-  val block_rmeta = RegInit(init = MetaData.default)
-  val flush_mode = RegInit(false.B)
-
-  val is_idle = state === s_IDLE
-  val is_read = state === s_READ_CACHE
-  val is_write = state === s_WRITE_CACHE
-  val is_alloc = state === s_REFILL && read_wrap_out
-  val is_alloc_reg = RegNext(is_alloc)
-
-  val hit = Wire(Bool())
-  val wen = is_write && (hit || is_alloc_reg) && !io.cpu.abort || is_alloc
-  val ren = !wen && (is_idle || is_read) && io.cpu.req.valid
-  val ren_reg = RegNext(ren)
-
-
-
-
-  //val rmeta = RegNext(next = metaMem.read(idx), init = MetaData.default)
-//  val rdata = RegNext(next = cache_block, init = 0.U(cache_block_size.W))
-//  val rdata_buf = RegEnable(rdata, ren_reg)
-  val refill_buf = RegInit(VecInit(Seq.fill(nData)(0.U(Axi_param.dataBits.W))))
-//  val read = Mux(is_alloc_reg, refill_buf.asUInt, Mux(ren_reg, rdata, rdata_buf))
-
-   //hit := (valid(idx_reg) & rmeta.tag === tag_reg)
-
-
-  def tagging ( tag:UInt, set:UInt, way:UInt){
-    val MD = new MetaData()
-    MD.tag := tag
-    metaMem(way)(set) := MD
-    tagValidation(set, way)
-  }
-
-  def detaggin( set:UInt, way:UInt){
-    tagInvalidation(set,way)
-  }
-  def allocate (addr:UInt, set:UInt, tag:UInt){
-    val (way) = addrToLoc (set)
-    tagging(tag, set, way)
-  }
-
-  def deallocate (set:UInt) {
-    val (way) = addrToLoc (set)
-    detaggin(set, way)
-  }
-
-  //  def Probing (addr:UInt): (UInt,UInt) ={
-  //    val set = addrToSet(addr)
-  //    val way = rplPolicy (set)
-  //    (set, way)
-  //  }
-
-  def Read (set: UInt, way: UInt) {
-//    val way = findInSet (set, tag)
-    val cache_block = Cat((dataMem map (_.read( set * nSets.U + way).asUInt)).reverse)
-    val cache_block_size = bBits
-
-  }
-
-
-
-  // Read Mux
-//  io.cpu.resp.bits.data := VecInit.tabulate(nWords)(i => read((i + 1) * xlen - 1, i * xlen))(offset)
-  io.cpu.resp.bits.tag := cpu_tag
-  io.cpu.resp.bits.valid := (is_write && hit) || (is_read && hit) || (is_alloc_reg && !cpu_iswrite)
-  io.cpu.resp.bits.iswrite := cpu_iswrite
-
-  //Extra input needs to be removed
-  //Extra input needs to be remove
-  io.cpu.resp.bits.tile := 0.U
-
-  // Can be: 1)Write hit, 2)Read hit, 3)Read miss
-  io.cpu.resp.valid := (is_write && hit) || (is_read && hit) || (is_alloc_reg && !cpu_iswrite)
-  io.cpu.req.ready := is_idle || (state === s_READ_CACHE && hit)
-
-
-
-//  val wmeta = MetaData(tag_reg)
-
-  // is_alloc means cache hit, hence, if is_alloc is false, it means our mask should consider only the modified byte
-  // and since wdata is masked with wmask we only duplicate the write data, otherwise, since mask doesn't do anything
-  // with write data we make the proper wdata using refill_buf
-//  val wmask = Mux(!is_alloc, (cpu_mask << Cat(off_reg, 0.U(byteOffsetBits.W))).asUInt.zext, (-1).asSInt()).asUInt()
-  //val wdata = Mux(!is_alloc, Fill(nWords, cpu_data),
-    //if (refill_buf.size == 1) io.mem.r.bits.data
-    //else Cat(io.mem.r.bits.data, Cat(refill_buf.init.reverse)))
-
-
-//  when(wen) {
-//    valid := valid.bitSet(set_reg, true.B)
-//    dirty := dirty.bitSet(set_reg, !is_alloc)
-
-    //    dirty_mem(dirty_block) := dirty_mem(dirty_block).bitSet(dirty_offset, !is_alloc)
-
-//    when(is_alloc) {
-//      metaMem.write(set_reg, wmeta)
-//    }
-//    dataMem.zipWithIndex foreach { case (mem, i) =>
-//      val data = VecInit.tabulate(wBytes)(k => wdata(i * xlen + (k + 1) * 8 - 1, i * xlen + k * 8))
-//      mem.write(set_reg, data, (wmask((i + 1) * wBytes - 1, i * wBytes)).asBools)
-//      mem suggestName s"dataMem_${i}"
-//    }
-//  }
-
-  //First elemt is ID and it looks like ID tags a memory request
-  // ID : Is AXI request ID
-  // @todo: Change @id value for each cache
-
-  // AXI constants - statically defined
-  io.mem.setConst()
-
-  // read request
-//  io.mem.ar.bits.addr := Cat(tag_reg, set_reg) << blen.U
-//  io.mem.ar.bits.len := (nData - 1).U
-//  io.mem.ar.valid := false.B
-
-  // read data
-//  io.mem.r.ready := state === s_REFILL
-//  when(io.mem.r.fire()) {
-//    refill_buf(read_count) := io.mem.r.bits.data
-//  }
-
-
-//  // Info
-//  val is_block_dirty = valid(set_count) && dirty(set_count)
-//  val block_addr = Cat(block_rmeta.tag, set_count - 1.U) << blen.U
-
-  // write addr
-  //io.mem.aw.bits.addr := Cat(rmeta.tag, idx_reg) << blen.U
-//  io.mem.aw.bits.addr := Mux(flush_mode, block_addr, Cat(rmeta.tag, set_reg) << blen.U)
-//  io.mem.aw.bits.len := (nData - 1).U
-//  io.mem.aw.valid := false.B
-
-  // Write resp
-  //io.mem.w.bits.data := VecInit.tabulate(dataBeats)(i => read((i + 1) * Axi_param.dataBits - 1, i * Axi_param.dataBits))(write_count)
-//  io.mem.w.bits.data :=
-//    Mux(flush_mode,
-//      VecInit.tabulate(nData)(i => dirty_cache_block((i + 1) * Axi_param.dataBits - 1, i * Axi_param.dataBits))(write_count),
-//      VecInit.tabulate(nData)(i => read((i + 1) * Axi_param.dataBits - 1, i * Axi_param.dataBits))(write_count))
-//
-//  io.mem.w.bits.last := write_wrap_out
-//  io.mem.w.valid := false.B
-//  io.mem.b.ready := false.B
-//
-//  io.cpu.flush_done := false.B
-
-  /**
-    * Dumping cache state should add for debugging purpose
-    */
-    /*
-  // io.stat := state.asUInt()
-  // Cache FSM
-  val countOn = true.B // increment counter every clock cycle
-  val (counterValue, counterWrap) = Counter(countOn, 64 * 1024)
-  //clockCycles := clockCycles + 1.U
-
-  val is_dirty = valid(set_reg) && dirty(set_reg)
-  switch(state) {
-    is(s_IDLE) {
-      when(io.cpu.req.valid) {
-        //state := Mux(io.cpu.req.bits.iswrite, s_WRITE_CACHE, s_READ_CACHE)
-        when(io.cpu.req.bits.iswrite) {
-          state := s_WRITE_CACHE
-          if (debug) {
-            printf("\nSTORE START: %d\n", counterValue)
-          }
-        }.otherwise {
-          state := s_READ_CACHE
-          if (debug) {
-            printf("\nLOAD START:  %d\n", counterValue)
-          }
-        }
-      }
-    }
-    is(s_READ_CACHE) {
-      when(hit) {
-        when(io.cpu.req.valid) {
-          when(io.cpu.req.bits.iswrite) {
-            state := s_WRITE_CACHE
-          }.otherwise {
-            state := s_READ_CACHE
-          }
-        }.otherwise {
-          state := s_IDLE
-          if (debug) {
-            printf("\nLOAD END: %d\n", counterValue)
-          }
-        }
-      }.otherwise {
-        io.mem.aw.valid := is_dirty
-        io.mem.ar.valid := !is_dirty
-        when(io.mem.aw.fire()) {
-          state := s_WRITE_BACK
-        }.elsewhen(io.mem.ar.fire()) {
-          state := s_REFILL
-        }
-      }
-    }
-    is(s_WRITE_CACHE) {
-      when(hit || is_alloc_reg || io.cpu.abort) {
-        state := s_IDLE
-        io.cpu.resp.valid := true.B
-        if (debug) {
-          printf("\nSTORE END: %d\n", counterValue)
-        }
-      }.otherwise {
-        if (debug) {
-          printf("\nSTORE MISS: %d\n", counterValue)
-        }
-        io.mem.aw.valid := is_dirty
-        io.mem.ar.valid := !is_dirty
-        when(io.mem.aw.fire()) {
-          state := s_WRITE_BACK
-        }.elsewhen(io.mem.ar.fire()) {
-          state := s_REFILL
-        }
-      }
-    }
-    is(s_WRITE_BACK) {
-      io.mem.w.valid := true.B
-      when(write_wrap_out) {
-        state := s_WRITE_ACK
-      }
-    }
-    is(s_WRITE_ACK) {
-      io.mem.b.ready := true.B
-      when(io.mem.b.fire()) {
-        state := s_REFILL_READY
-      }
-    }
-    is(s_REFILL_READY) {
-      io.mem.ar.valid := true.B
-      when(io.mem.ar.fire()) {
-        state := s_REFILL
-      }
-    }
-    is(s_REFILL) {
-      if (debug) {
-        printf(p"state: Refill\n")
-      }
-      when(read_wrap_out) {
-        state := Mux(cpu_iswrite.asBool(), s_WRITE_CACHE, s_IDLE)
-        when(!cpu_iswrite) {
-          if (debug) {
-            printf("\nLOAD END: %d\n", counterValue)
-          }
-        }
-      }
-    }
-  }
-
-  //Flush state machine
-  switch(flush_state) {
-    is(s_flush_IDLE) {
-      when(io.cpu.flush) {
-        flush_state := s_flush_START
-        flush_mode := true.B
-      }
-    }
-    is(s_flush_START) {
-      when(set_wrap) {
-        io.cpu.flush_done := true.B
-        flush_mode := false.B
-        flush_state := s_flush_IDLE
-      }.elsewhen(is_block_dirty) {
-        flush_state := s_flush_ADDR
-        block_rmeta := metaMem.read(set_count)
-      }
-    }
-    is(s_flush_ADDR) {
-      /**
-        * When cycle delay to read from metaMem
-        */
-      flush_state := s_flush_WRITE
-    }
-    is(s_flush_WRITE) {
-      if (clog) {
-        printf(p"Dirty block address: 0x${Hexadecimal(block_addr)}\n")
-        printf(p"Dirty block data: 0x${Hexadecimal(dirty_cache_block)}\n")
-      }
-
-      io.mem.aw.valid := true.B
-      io.mem.ar.valid := false.B
-
-      when(io.mem.aw.fire()) {
-        flush_state := s_flush_WRITE_BACK
-      }
-    }
-    is(s_flush_WRITE_BACK) {
-      if (clog) {
-        printf(p"Write data: ${VecInit.tabulate(nData)(i => dirty_cache_block((i + 1) * Axi_param.dataBits - 1, i * Axi_param.dataBits))(write_count)}\n")
-      }
-      io.mem.w.valid := true.B
-      when(write_wrap_out) {
-        flush_state := s_flush_WRITE_ACK
-      }
-    }
-    is(s_flush_WRITE_ACK) {
-      io.mem.b.ready := true.B
-      when(io.mem.b.fire()) {
-        flush_state := s_flush_START
-      }
-    }
-  }
-*/
-}
-/*
 class SimpleCache(val ID: Int = 0, val debug: Boolean = false)(implicit val p: Parameters) extends Module
   with HasCacheAccelParams
   with HasAccelShellParams {
@@ -860,8 +404,6 @@ class SimpleCache(val ID: Int = 0, val debug: Boolean = false)(implicit val p: P
  * @param debug
  * @param p
  */
-
-
 class ReferenceCache(val ID: Int = 0, val debug: Boolean = false)(implicit val p: Parameters) extends Module
   with HasAccelParams
   with HasCacheAccelParams
@@ -1439,5 +981,3 @@ class DMECache(val ID: Int = 0, val debug: Boolean = false)(implicit val p: Para
     }
   }
 }
-
-*/
